<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/>
<title>GalEx - We Connect Worlds!</title>
<link rel="shortcut icon" href="icon.png"/>
<style>

body
{
	background: #fff; color: #333;
	margin: 0; padding: 0;
	overflow: hidden;
	-ms-touch-action: none;
}

canvas
{
	position: fixed;
	left: 0; top: 0;
	z-index: 1;
}

#Message
{
	position: fixed;
	z-index: 9;
	left: 0; top: 0;
	right: 0; bottom: 0;
	width: 100%; height: 100%;
	padding: 0;
	background: #fff center center url( title.png ) no-repeat;
	background-size: 80%;
	-webkit-transform-style: preserve-3d;
	-moz-transform-style: preserve-3d;
	transform-style: preserve-3d;
}

#MessageText
{
	position: relative;
	top: 50%;
	-webkit-transform: translateY( -50% );
	-ms-transform: translateY( -50% );
	transform: translateY( -50% );
	max-width: 30em;
	margin: 0 auto; padding: 0;
	font: 16pt sans-serif;
	font-weight: lighter;
	letter-spacing: .2em;
	line-height: 150%;
	text-align: center;
	text-transform: uppercase;
}

h1
{
	margin-top: 0;
	line-height: 150%;
	text-transform: none;
	font-variant: small-caps;
}

@media screen and (max-width: 900px), screen and (max-height: 560px)
{
	#MessageText
	{
		width: 90%;
		font-size: 16pt;
	}
}

@media screen and (max-width: 700px), screen and (max-height: 420px)
{
	#MessageText
	{
		width: 90%;
		font-size: 10pt;
	}
}

@media screen and (max-width: 360px), screen and (max-height: 360px)
{
	#MessageText
	{
		width: 90%;
		font-size: 8pt;
	}
}

</style>
<head>
<body>
<div id="Message"><div id="MessageText">Initializing...</div></div>
<script>

"use strict";

Math.PI2 = Math.PI2 || Math.PI/2;
Math.TAU = Math.TAU || Math.PI*2;

var requestAnimFrame =
		window.requestAnimationFrame ||
		window.webkitRequestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.msRequestAnimationFrame ||
		window.oRequestAnimationFrame ||
		function( callback )
		{
			window.setTimeout( callback, 16 );
		},
	resources = {
		ship: { rect: {/*ship*/x:634,y:505,w:114,h:120}, rotate: true },
		debris: { rect: {/*debris*/x:606,y:774,w:100,h:100} },
		world0: { rect: {/*world0*/x:746,y:634,w:140,h:140} },
		world1: { rect: {/*world1*/x:748,y:505,w:113,h:113} },
		world2: { rect: {/*world2*/x:606,y:634,w:140,h:140} },
		world3: { rect: {/*world3*/x:634,y:316,w:189,h:189} },
		world4: { rect: {/*world4*/x:280,y:634,w:179,h:178} },
		world5: { rect: {/*world5*/x:634,y:0,w:250,h:316} },
		world6: { rect: {/*world6*/x:459,y:634,w:147,h:147} },
		blackhole: { rect: {/*blackhole*/x:0,y:0,w:634,h:634} },
		star0: { rect: {/*star0*/x:823,y:316,w:23,h:23} },
		star1: { rect: {/*star1*/x:846,y:316,w:21,h:21} },
		star2: { rect: {/*star2*/x:823,y:339,w:19,h:19} },
		star3: { rect: {/*star3*/x:867,y:316,w:16,h:16} },
		exhaust: { rect: {/*exhaust*/x:459,y:781,w:87,h:87} },
		mail: { rect: {/*mail*/x:280,y:812,w:75,h:75} },
		arrow: { rect: {/*arrow*/x:746,y:774,w:105,h:149}, rotate: true },
		check: { rect: {/*check*/x:0,y:634,w:280,h:237} },
	},
	defaultDistance = 8*resources.ship.rect.h,
	level = 0,
	levels = [
		function()
		{
			objectsLength = 1;

			var r = resources.world0.rect.w,
				x = shipX,
				y = shipY;

			y -= defaultDistance;

			objects[0] = {
				spriteName: "world0",
				delivered: false,
				radius: r >> 1,
				radiusMail: r << 1,
				x: x,
				y: y,
				g: 2000 };
		},
		function()
		{
			objectsLength = 3;

			var x = shipX,
				y = shipY,
				d = defaultDistance;

			for( var n = objectsLength; n--; )
			{
				var name = "world"+(n+2),
					r = resources[name].rect.w;

				y -= d;
				x = Math.sin( y )*d;

				objects[n] = {
					spriteName: name,
					delivered: false,
					radius: r >> 1,
					radiusMail: r << 1,
					x: x,
					y: y,
					g: 2000 };

				d *= .5;
			}
		},
		function()
		{
			objectsLength = 7;

			var x = shipX,
				y = shipY;

			for( var n = objectsLength; n--; )
			{
				var name = "world"+n,
					r = resources[name].rect.w;

				y -= defaultDistance;

				objects[n] = {
					spriteName: name,
					delivered: false,
					radius: r >> 1,
					radiusMail: r << 1,
					x: x,
					y: y,
					g: 3000 };

				x = Math.sin( y )*defaultDistance;
			}

			y -= defaultDistance;

			objects[objectsLength++] = {
				spriteName: "blackhole",
				delivered: true,
				radius: resources.blackhole.rect.w >> 3,
				radiusMail: 0,
				x: x,
				y: y,
				g: 50000 };
		},
		function()
		{
			objectsLength = 2;

			var x = shipX,
				y = shipY;

			y -= defaultDistance;

			objects[1] = {
				spriteName: "blackhole",
				delivered: true,
				radius: resources.blackhole.rect.w >> 3,
				radiusMail: 0,
				x: x,
				y: y,
				g: 50000 };

			y -= defaultDistance;

			var r = resources.world4.rect.w;
			objects[0] = {
				spriteName: "world4",
				delivered: false,
				radius: r >> 1,
				radiusMail: r << 1,
				x: x,
				y: y,
				g: 2000 };
		},
		function()
		{
			objectsLength = 7;

			var x = shipX,
				y = shipY,
				step = Math.TAU/objectsLength,
				a = 0;

			for( var n = objectsLength; n--; )
			{
				var name = "world"+((n+4) % 7),
					r = resources[name].rect.w,
					d = Math.cos( a )*defaultDistance;

				objects[n] = {
					spriteName: name,
					delivered: false,
					radius: r >> 1,
					radiusMail: r << 1,
					x: Math.cos( a )*d,
					y: Math.sin( a )*d,
					g: 3000 };

				a += step;
			}
		},
		function()
		{
			objectsLength = 12;

			var x = shipX,
				y = shipY-defaultDistance*2,
				step = Math.TAU/objectsLength,
				a = 0;

			for( var n = objectsLength; n--; )
			{
				var name = "world"+(n % 7),
					r = resources[name].rect.w,
					d = defaultDistance;

				objects[n] = {
					spriteName: name,
					delivered: false,
					radius: r >> 1,
					radiusMail: r << 1,
					x: x+Math.cos( a )*d,
					y: y+Math.sin( a )*d,
					g: 3000 };

				a += step;
			}

			objects[objectsLength++] = {
				spriteName: "blackhole",
				delivered: true,
				radius: resources.blackhole.rect.w >> 3,
				radiusMail: 0,
				x: x,
				y: y,
				g: 50000 };
		},
	],
	atlas,
	message,
	clickOrTouch,
	resizeTimer,
	crashMessageTimer,
	canvas,
	ctx,
	ratio,
	width,
	height,
	centerX,
	centerY,
	gridCellSize,
	orientationsLength = 72,
	orientationFactor = orientationsLength/Math.TAU,
	scaleFactor,
	sprites = [],
	now,
	last,
	factor,
	blindUntil,
	pointerLength = 0,
	pointerX = [],
	pointerY = [],
	keysDown = [],
	starsLength,
	stars = [],
	objectsLength,
	objects = [],
	debrisLength = 20,
	debrisCursor,
	debris = [],
	exhaustsLength = 20,
	exhaustsNext,
	exhaustsCursor,
	exhausts = [],
	exhaustDisplacement,
	mailsToDeliver,
	mailsDelivered,
	mailsLength = 20,
	mailsCursor,
	mails = [],
	arrowRadius,
	shipAlive,
	shipAngle,
	shipVx,
	shipVy,
	shipX,
	shipY,
	maxV = 8;

function drawSprite( sprite, x, y )
{
	ctx.drawImage(
		sprite,
		(x-sprite.centerX) | 0,
		(y-sprite.centerY) | 0 );
}

function drawDebris( x, y )
{
	for( var n = debrisLength; n--; )
	{
		var d = debris[n];

		if( d.live < now )
			continue;

		d.x += d.vx;
		d.y += d.vy;

		ctx.globalAlpha = .002*(d.live-now);
		drawSprite(
			sprites.debris,
			centerX+(d.x-x),
			centerY+(d.y-y) );
		ctx.globalAlpha = 1;
	}
}

function drawArrow( x, y )
{
	for( var n = objectsLength; n--; )
	{
		var o = objects[n];

		if( o.delivered )
			continue;

		x = o.scaledX-x,
		y = o.scaledY-y;

		var sx = centerX+x,
			sy = centerY+y;

		if( sx < 0 ||
			sx > width ||
			sy < 0 ||
			sy > height )
		{
			var a = Math.atan2( y, x ),
				ax = Math.cos( a )*arrowRadius,
				ay = Math.sin( a )*arrowRadius;

			a = (a+Math.PI2+Math.TAU) % Math.TAU;

			drawSprite(
				sprites.arrow[orientationFactor*a | 0],
				centerX+ax,
				centerY+ay );
		}

		break;
	}
}

function drawMails( x, y )
{
	for( var n = mailsLength; n--; )
	{
		var m = mails[n];

		if( !m.dropped )
			continue;

		if( m.delivered )
		{
			drawSprite(
				sprites.check,
				centerX+(m.tx-x),
				centerY+(m.ty-y) );

			continue;
		}

		m.x += m.vx;
		m.y += m.vy;

		if( Math.abs( m.tx-m.x ) < 4 &&
			Math.abs( m.ty-m.y ) < 4 )
		{
			++mailsDelivered;
			m.delivered = true;
			continue;
		}

		drawSprite(
			sprites.mail,
			centerX+(m.x-x),
			centerY+(m.y-y) );
	}
}

function drawObjects( x, y )
{
	for( var n = objectsLength; n--; )
	{
		var o = objects[n];

		drawSprite(
			o.sprite,
			centerX+(o.scaledX-x),
			centerY+(o.scaledY-y) );
	}
}

function drawExhausts( x, y )
{
	for( var n = exhaustsLength; n--; )
	{
		var e = exhausts[n];

		if( e.live < now )
			continue;

		e.x += e.vx;
		e.y += e.vy;

		ctx.globalAlpha = .001*(e.live-now);
		drawSprite(
			sprites.exhaust,
			centerX+(e.x-x),
			centerY+(e.y-y) );
		ctx.globalAlpha = 1;
	}
}

function drawStars()
{
	var vx = shipVx*scaleFactor,
		vy = shipVy*scaleFactor;

	for( var n = starsLength; n--; )
	{
		var s = stars[n],
			x = s.x,
			y = s.y;

		x -= vx;
		y -= vy;

		if( x < 0 ||
			x > width ||
			y < 0 ||
			y > height )
		{
			var p = 0,
				range = width+height;

			if( !(vx*100 | 0) )
			{
				range -= height;
			}

			if( !(vy*100 | 0) )
			{
				p = width;
				range -= width;
			}

			p += range*Math.random() | 0;

			if( p > width )
			{
				x = vx > 0 ? width : 0;
				y = p-width;
			}
			else
			{
				x = p;
				y = vy > 0 ? height : 0;
			}
		}

		drawSprite( s.sprite, x, y );
		s.x = x;
		s.y = y;
	}
}

function drawGrid( x, y )
{
	ctx.strokeStyle = "#f0f0f0";
	ctx.beginPath();

	for( var g = -(y % gridCellSize); g < height; )
	{
		ctx.moveTo( 0, g );
		ctx.lineTo( width, g );
		g += gridCellSize;
	}

	for( var g = -(x % gridCellSize); g < width; )
	{
		ctx.moveTo( g, 0 );
		ctx.lineTo( g, height );
		g += gridCellSize;
	}

	ctx.stroke();
}

function draw()
{
	ctx.fillStyle = "#fff";
	ctx.fillRect( 0, 0, width, height );

	var x = shipX*scaleFactor,
		y = shipY*scaleFactor;

	drawGrid( x, y );
	drawStars();
	drawExhausts( x, y );
	drawObjects( x, y );
	drawMails( x, y );
	drawArrow( x, y );

	if( shipAlive )
		drawSprite(
			sprites.ship[orientationFactor*shipAngle | 0],
			centerX,
			centerY );
	else
		drawDebris( x, y );
}

function calculateMailVector( m )
{
	var o = m.target,
		ox = o.scaledX,
		oy = o.scaledY;

	if( m.delivered )
	{
		m.tx = ox;
		m.ty = oy;
	}

	var dx = ox-m.x,
		dy = oy-m.y,
		d = Math.sqrt( dx*dx + dy*dy ),
		f = d/(4*scaleFactor);

	m.tx = ox;
	m.ty = oy;
	m.vx = dx/f;
	m.vy = dy/f;
}

function mailsAdd( o )
{
	++mailsCursor;
	mailsCursor %= mailsLength;

	var m = mails[mailsCursor];

	m.target = o;
	m.dropped = true;
	m.x = shipX*scaleFactor;
	m.y = shipY*scaleFactor;

	calculateMailVector( m );
}

function mailsReset()
{
	mailsToDeliver = mailsDelivered = mailsCursor = 0;

	for( var n = mailsLength; n--; )
	{
		var m = mails[n];

		m.dropped = m.delivered = false;
	}

	for( var n = objectsLength; n--; )
		if( !objects[n].delivered )
			++mailsToDeliver;

}

function mailsInit()
{
	for( var n = mailsLength; n--; )
		mails[n] = {};

	mailsReset();
}

function exhaustsAdd()
{
	if( now < exhaustsNext )
		return;

	exhaustsNext = now+20;
	++exhaustsCursor;
	exhaustsCursor %= exhaustsLength;

	var e = exhausts[exhaustsCursor];
	e.vx = -shipVx*.5*scaleFactor;
	e.vy = -shipVy*.5*scaleFactor;
	e.x = shipX*scaleFactor+Math.sin( -shipAngle )*exhaustDisplacement;
	e.y = shipY*scaleFactor+Math.cos( -shipAngle )*exhaustDisplacement;
	e.live = now+500;
}

function exhaustsReset()
{
	exhaustsNext = exhaustsCursor = 0;

	for( var n = exhaustsLength; n--; )
		exhausts[n].live = 0;
}

function exhaustsInit()
{
	for( var n = exhaustsLength; n--; )
		exhausts[n] = {};

	exhaustsReset();
}

function thrust( power )
{
	var a = (shipAngle+Math.PI2) % Math.TAU,
		p = power*scaleFactor*ratio*factor;

	shipVx -= Math.cos( a )*p;
	shipVy -= Math.sin( a )*p;

	exhaustsAdd();
}

function turn( mod )
{
	shipAngle = (shipAngle+mod+Math.TAU) % Math.TAU;
}

function scalePositions()
{
	for( var n = objectsLength; n--; )
	{
		var o = objects[n];

		o.sprite = sprites[o.spriteName];
		o.scaledX = o.x*scaleFactor | 0;
		o.scaledY = o.y*scaleFactor | 0;
	}
}

function reset()
{
	shipX = shipY = shipVx = shipVy = shipAngle = 0;
	shipAlive = true;

	blindUntil = 0;

	levels[level]();
	scalePositions();

	debrisReset();
	exhaustsReset();
	mailsReset();
}

function input()
{
	if( !shipAlive )
	{
		if( !crashMessageTimer &&
			blindUntil < now &&
			(pointerLength > 0 ||
				keysDown[32] ||
				keysDown[13]) )
		{
			pointerLength = 0;
			message.style.display = "none";
			reset();
		}

		return;
	}

	if( keysDown[82] )
	{
		reset();
		return;
	}

	var step = .05,
		power = .75;

	for( var n = pointerLength; n--; )
	{
		var x = pointerX[n]-centerX,
			y = pointerY[n]-centerY,
			a = Math.atan2( y, x )+Math.PI2,
			d = ((shipAngle-a)+Math.TAU) % Math.TAU;

		if( d > Math.PI )
			d -= Math.TAU;

		if( d > .1  )
			turn( -step );
		else if( d < .1 )
			turn( step );

		thrust( power );
	}

	if( keysDown[37] )
		turn( -step );
	else if( keysDown[39] )
		turn( step );

	if( keysDown[38] )
		thrust( power );
}

function disableShip()
{
	shipVx = shipVy = 0;
	shipAlive = false;
}

function showMessage( text )
{
	disableShip();
	blindUntil = now+200;
	pointerLength = 0;

	message.text.innerHTML = text;
	message.style.display = "block";
}

function debrisBurst()
{
	for( var n = debrisLength; n--; )
	{
		var d = debris[n];

		d.x = shipX*scaleFactor;
		d.y = shipY*scaleFactor;
		d.vx =
			shipVx*.1+
			Math.cos( Math.random()*Math.TAU )*
			Math.random()*6*scaleFactor;
		d.vy =
			shipVy*.1+
			Math.sin( Math.random()*Math.TAU )*
			Math.random()*6*scaleFactor;
		d.live = now+500;
	}
}

function debrisReset()
{
	for( var n = debrisLength; n--; )
		debris[n].live = 0;
}

function debrisInit()
{
	for( var n = debrisLength; n--; )
		debris[n] = {};

	debrisReset();
}

function crash()
{
	if( crashMessageTimer )
		return;

	debrisBurst();
	disableShip();

	crashMessageTimer = setTimeout(
		function()
		{
			clearTimeout( crashMessageTimer );
			crashMessageTimer = null;

			showMessage(
				"<p>You crashed!</p>"+
				"<p>"+clickOrTouch+" to try again.</p>" );
		},
		500 );
}

function gravity()
{
	if( !shipAlive )
		return;

	for( var n = objectsLength; n--; )
	{
		var o = objects[n],
			dx = o.x-shipX,
			dy = o.y-shipY,
			d = Math.sqrt( dx*dx + dy*dy );

		if( d < o.radius )
		{
			crash();
			break;
		}
		else if( d < o.radiusMail &&
			!o.delivered )
		{
			o.delivered = true;
			mailsAdd( o );
		}

		d /= o.g/(d*d);
		d *= factor;

		shipVx += dx/d,
		shipVy += dy/d;
	}
}

function nextLevel()
{
	var message;

	if( ++level == levels.length )
	{
		level %= levels.length;

		message =
			"<p>Congratulations!</p>"+
			"<p>You beat the game.</p>"+
			"<p>"+clickOrTouch+" if you want to play again.</p>";
	}
	else
		message =
			"<p>All mail delivered!</p>"+
			"<p>"+clickOrTouch+" to level up.</p>";

	showMessage( message );
}

function run()
{
	now = new Date().getTime();
	factor = (now-last)/16;
	last = now;

	gravity();
	input();

	if( shipAlive )
	{
		if( shipVx > maxV )
			shipVx = maxV;
		else if( shipVx < -maxV )
			shipVx = -maxV;

		if( shipVy > maxV )
			shipVy = maxV;
		else if( shipVy < -maxV )
			shipVy = -maxV;

		shipX += shipVx;
		shipY += shipVy;

		if( mailsDelivered >= mailsToDeliver )
			nextLevel();
	}

	draw();

	requestAnimFrame( run );
}

function setPointers( ev, down )
{
	var e = ev || event;

	if( down < 1 )
	{
		// process remaining touches
		if( pointerLength > 0 &&
			e.touches &&
			(down = e.touches.length) )
			return setPointers( e, down );

		pointerLength = 0;
	}
	else if( e.touches )
	{
		pointerLength = e.touches.length;

		for( var n = 0; n < pointerLength; ++n )
		{
			var t = e.touches[n];

			pointerX[n] = t.pageX;
			pointerY[n] = t.pageY;
		}
	}
	else if( typeof e.clientX !== "undefined" )
	{
		pointerX[0] = e.clientX;
		pointerY[0] = e.clientY;
		pointerLength = 1;
	}
	else if( typeof e.pageX !== "undefined" )
	{
		pointerX[0] = e.pageX;
		pointerY[0] = e.pageY;
		pointerLength = 1;
	}

	if( ratio != 1 )
		for( var n = 0; n < pointerLength; ++n )
		{
			pointerX[n] = pointerX[n]*ratio | 0;
			pointerY[n] = pointerY[n]*ratio | 0;
		}

	// to avoid overscrolling on iOS it's important to
	// catch pointer events
	e.preventDefault();
	return false;
}

function pointerUp( ev )
{
	return setPointers( ev, 0 );
}

function pointerMove( ev )
{
	return setPointers( ev, pointerLength );
}

function pointerDown( ev )
{
	return setPointers( ev, 1 );
}

function setKey( ev, pressed )
{
	var e = ev || event;

	keysDown[e.keyCode] = pressed;

	e.preventDefault();
	return false;
}

function keyUp( ev )
{
	return setKey( ev, false );
}

function keyDown( ev )
{
	return setKey( ev, true );
}

function rotateSprite( res, rect, w, h )
{
	w = Math.max( 1, w );
	h = Math.max( 1, h );

	var step = Math.TAU/orientationsLength,
		size = Math.max( w, h )*1.4142,
		center = size >> 1,
		a = [];

	for( var o = orientationsLength; o--; )
	{
		var c = document.createElement( "canvas" ),
			x = c.getContext( "2d" ),
			angle = o*step;

		c.width = size;
		c.height = size;

		c.centerX = center;
		c.centerY = center;

		if( res.mirror )
		{
			x.setTransform( -1, 0, 0, 1, 0, 0 );
			x.translate( -center, center );
			x.rotate( -angle );
		}
		else if( res.upsideDown )
		{
			x.setTransform( -1, 0, 0, -1, 0, 0 );
			x.translate( -center, -center );
			x.rotate( -angle );
		}
		else
		{
			x.translate( center, center );
			x.rotate( angle );
		}

		x.drawImage(
			atlas,
			rect.x | 0,
			rect.y | 0,
			rect.w | 0,
			rect.h | 0,
			-w >> 1,
			-h >> 1,
			w | 0,
			h | 0 );

		a[o] = c;
	}

	return a;
}

function scaleSprite( frame, rect, w, h )
{
	var c = document.createElement( "canvas" ),
		x = c.getContext( "2d" ),
		l = 0,
		t = 0;

	w = Math.max( 1, w );
	h = Math.max( 1, h );

	c.width = w;
	c.height = h;

	c.centerX = w >> 1;
	c.centerY = h >> 1;

	if( frame.mirror )
	{
		x.setTransform( -1, 0, 0, 1, 0, 0 );
		l = -w;
	}
	else if( frame.upsideDown )
	{
		x.setTransform( -1, 0, 0, -1, 0, 0 );
		l = -w;
		t = -h;
	}

	x.drawImage(
		atlas,
		rect.x | 0,
		rect.y | 0,
		rect.w | 0,
		rect.h | 0,
		l | 0,
		t | 0,
		w | 0,
		h | 0 );

	return c;
}

function scale()
{
	scaleFactor = (Math.min( width, height )/20)/resources.ship.rect.h;

	for( var name in resources )
	{
		var res = resources[name],
			rc = res.rect,
			w = rc.w*scaleFactor | 0,
			h = rc.h*scaleFactor | 0;

		sprites[name] = res.rotate ?
			rotateSprite( res, rc, w, h ) :
			scaleSprite( res, rc, w, h );
	}
}

function resize()
{
	var w = window.innerWidth,
		h = window.innerHeight;

	width = w*ratio | 0;
	height = h*ratio | 0;

	centerX = width >> 1;
	centerY = height >> 1;

	var min = Math.min( width, height );

	gridCellSize = min >> 3;
	starsLength = (100/2048*Math.min( 2048, width+height )) | 0;
	arrowRadius = min*.4 | 0;

	canvas.width = width;
	canvas.height = height;
	canvas.style.width = w+"px";
	canvas.style.height = h+"px";

	scale();
	scalePositions();

	for( var n = starsLength; n--; )
	{
		var size = ((Math.random()*4) % 4) | 0;

		stars[n] = {
			x: Math.random()*width | 0,
			y: Math.random()*height | 0,
			sprite: sprites["star"+size] };
	}

	for( var n = mailsLength; n--; )
	{
		var m = mails[n];

		if( !m.dropped )
			continue;

		calculateMailVector( m );
	}

	exhaustDisplacement = sprites.ship[0].height >> 1;

	if( shipAlive &&
		message.resizing )
		message.style.display = "none";
}

function scheduleResize()
{
	if( resizeTimer )
		clearTimeout( resizeTimer );

	if( message.started &&
		shipAlive )
	{
		message.resizing = true;
		message.text.innerHTML = "Resizing...";
		message.style.display = "block";
	}

	resizeTimer = setTimeout( resize, 200 );
}

function createCanvas()
{
	if( !(canvas = document.createElement( "canvas" )) ||
		!(ctx = canvas.getContext( "2d", { alpha: false } )) )
		return false;

	document.body.appendChild( canvas );

	ratio =
		(window.devicePixelRatio || 1)/
		(ctx.webkitBackingStorePixelRatio ||
			ctx.mozBackingStorePixelRatio ||
			ctx.msBackingStorePixelRatio ||
			ctx.oBackingStorePixelRatio ||
			ctx.backingStorePixelRatio ||
			1);

	return true;
}

function init()
{
	if( !atlas.complete ||
		new Date().getTime()-last < 500 )
	{
		// give mobile browsers some time to settle
		// their window.innerWidth/Height values, i.e.
		// there may still be the virtual keyboard visible
		setTimeout( init, 500 );
		return;
	}

	if( !createCanvas() )
	{
		message.text.innerHTML =
			"Sorry, this browser cannot run this game.";

		return;
	}

	ctx.lineWidth = 1;

	debrisInit();
	exhaustsInit();
	mailsInit();

	reset();

	resize();
	window.onresize = scheduleResize;

	var d = document;

	clickOrTouch = "ontouchstart" in d ? "Touch" : "Click";

	message.text.innerHTML =
		"<h1>Welcome to GalEx!</h1>"+
		"<p>Connecting worlds by delivering mail.</p>"+
		"<p>"+clickOrTouch+" when ready!</p>";

	d.onkeyup = message.onclick = function( ev )
	{
		message.style.display = "none";
		message.started = true;

		// don't use onclick() after that; it'll interfere
		// with onmouse*/ontouch* events
		message.onclick = function( ev )
		{
			(ev || event).preventDefault();
			return false;
		};

		d.onkeydown = keyDown;
		d.onkeyup = keyUp;

		d.onmousedown = pointerDown;
		d.onmousemove = pointerMove;
		d.onmouseup = pointerUp;
		d.onmouseout = pointerUp;

		if( "ontouchstart" in d )
		{
			d.ontouchstart = pointerDown;
			d.ontouchmove = pointerMove;
			d.ontouchend = pointerUp;
		}

		run();

		(ev || event).preventDefault();
		return false;
	};
}

function load()
{
	if( !(message = document.getElementById( "Message" )) ||
		!(message.text = document.getElementById( "MessageText" )) )
		return;

	message.text.innerHTML = "Loading...";

	last = new Date().getTime();

	if( atlas &&
		atlas.complete )
	{
		init();
		return;
	}

	atlas = new Image();
	atlas.src = "atlas.png";
	atlas.onload = init;
}

window.onload = load;

</script>
</body>
</html>
